/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"errors"
	"fmt"
	"io"
	"reflect"
	"strings"

	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/code-generator/cmd/validation-gen/generators/validators"
	"k8s.io/gengo/v2"
	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/types"
	"k8s.io/klog/v2"
)

// genValidations produces a file with autogenerated validations.
type genValidations struct {
	generator.GoGenerator
	typesPackage         string
	outputPackage        string
	peerPackages         []string
	validations          validationFuncMap
	imports              namer.ImportTracker
	typesForInit         []*types.Type
	generated            sets.Set[*types.Type]
	declarativeValidator validators.DeclarativeValidator
}

func NewGenValidations(outputFilename, typesPackage, outputPackage string, validations validationFuncMap, peerPkgs []string, declarativeValidator validators.DeclarativeValidator) generator.Generator {
	return &genValidations{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename,
		},
		typesPackage:         typesPackage,
		outputPackage:        outputPackage,
		peerPackages:         peerPkgs,
		validations:          validations,
		imports:              generator.NewImportTrackerForPackage(outputPackage),
		typesForInit:         make([]*types.Type, 0),
		generated:            sets.New[*types.Type](),
		declarativeValidator: declarativeValidator,
	}
}

func (g *genValidations) Namers(_ *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.outputPackage, g.imports),
	}
}

func (g *genValidations) isOtherPackage(pkg string) bool {
	if pkg == g.outputPackage {
		return false
	}
	if strings.HasSuffix(pkg, `"`+g.outputPackage+`"`) {
		return false
	}
	return true
}

func (g *genValidations) Filter(_ *generator.Context, t *types.Type) bool {
	validations, ok := g.validations[t]
	if !ok || validations.object == nil {
		return false
	}
	g.typesForInit = append(g.typesForInit, t)
	return true
}

func (g *genValidations) Imports(_ *generator.Context) (imports []string) {
	var importLines []string
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func (g *genValidations) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	if _, ok := g.validations[t]; !ok {
		return nil
	}

	klog.V(5).Infof("generating for type %v", t)

	callTree, err := newCallTreeForType(g.declarativeValidator, g.validations).build(t, true)
	if err != nil {
		return err
	}
	if callTree == nil {
		klog.V(5).Infof("  no validations defined")
		return nil
	}
	var errs []error
	callTree.VisitInOrder(func(ancestors []*callNode, current *callNode) {
		sw := generator.NewSnippetWriter(w, c, "$", "$")
		if current.validationType != nil && current.validationType.Kind == types.Struct {
			g.generateValidations(c, current.validationType, current, sw)
			if err := sw.Error(); err != nil {
				errs = append(errs, err)
			}
		}
	})
	return errors.Join(errs...)
}

func validationArgsFromType(inType *types.Type) generator.Args {
	return generator.Args{
		"inType": inType,
	}
}

func (g *genValidations) generateValidations(c *generator.Context, inType *types.Type, callTree *callNode, sw *generator.SnippetWriter) {
	if g.generated.Has(inType) {
		return
	}
	g.generated.Insert(inType)

	validationArgsFromType(inType)
	args := generator.Args{
		"inType":    inType,
		"errorList": c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/util/validation/field", Name: "ErrorList"}),
		"fieldPath": c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/util/validation/field", Name: "Path"}),
	}

	sw.Do("func $.inType|objectvalidationfn$(in *$.inType|raw$, fldPath *$.fieldPath|raw$) (errs $.errorList|raw$) {\n", args)
	// TODO: is it OK to pass an empty fieldName here? How do we document/justify this?
	callTree.WriteMethod(c, "in", pathPart{}, 0, nil, sw)
	sw.Do("return errs\n", nil)
	sw.Do("}\n\n", nil)
}

// These are the comment tags that carry parameters for defaulter generation.
const (
	tagName      = "k8s:validation-gen"
	inputTagName = "k8s:validation-gen-input"
)

func extractTag(comments []string) []string {
	return gengo.ExtractCommentTags("+", comments)[tagName]
}

func extractInputTag(comments []string) []string {
	return gengo.ExtractCommentTags("+", comments)[inputTagName]
}

func checkTag(comments []string, require ...string) bool {
	values := gengo.ExtractCommentTags("+", comments)[tagName]
	if len(require) == 0 {
		return len(values) == 1 && values[0] == ""
	}
	return reflect.DeepEqual(values, require)
}

// typeValidations holds the type that a validation should be generated for,
// and the validations that should be generated for that type.
type typeValidations struct {
	object *types.Type

	// validations validate the object
	validations *validations
}

// TODO: Should this instead be function calls into kube-openapi validation utils?
// such as https://github.com/kubernetes/kube-openapi/blob/3c01b740850fe616122fe83225f9280f28471f40/pkg/validation/validate/values.go#L104
type validations []validators.FunctionGen

type validationFuncMap map[*types.Type]typeValidations

// callTreeForType contains fields necessary to build a tree for types.
type callTreeForType struct {
	declarativeValidator   validators.DeclarativeValidator
	validations            validationFuncMap
	currentlyBuildingTypes map[*types.Type]bool
}

func newCallTreeForType(declarativeValidator validators.DeclarativeValidator, validations validationFuncMap) *callTreeForType {
	return &callTreeForType{
		declarativeValidator:   declarativeValidator,
		validations:            validations,
		currentlyBuildingTypes: make(map[*types.Type]bool),
	}
}

// resolveType follows pointers and aliases of `t` until reaching the first
// non-pointer type in `t's` hierarchy
func resolveTypeAndDepth(t *types.Type) (*types.Type, int) {
	var prev *types.Type
	depth := 0
	for prev != t {
		prev = t
		if t.Kind == types.Alias {
			t = t.Underlying
		} else if t.Kind == types.Pointer {
			t = t.Elem
			depth += 1
		}
	}
	return t, depth
}

// getNestedValidations returns the first validation when resolving alias types
func (c *callTreeForType) getNestedValidations(t *types.Type) (validations, error) {
	var prev *types.Type
	var valueValidations validations
	for prev != t {
		prev = t
		v, err := c.declarativeValidator.ExtractValidations(t, t.CommentLines)
		if err != nil {
			return nil, err
		}
		// TODO: Find and return all validations?
		if len(v) > 0 {
			return v, nil
		}
		if t.Kind == types.Alias {
			t = t.Underlying
		} else if t.Kind == types.Pointer {
			t = t.Elem
		}
	}
	return valueValidations, nil
}

func (c *callTreeForType) populateValidations(node *callNode, t *types.Type, commentLines []string) (*callNode, error) {
	valueValidations, err := c.declarativeValidator.ExtractValidations(t, commentLines)
	if err != nil {
		return nil, err
	}

	baseT, depth := resolveTypeAndDepth(t)
	if depth > 0 && len(valueValidations) == 0 {
		valueValidations, err = c.getNestedValidations(t)
		if err != nil {
			return nil, err
		}
	}

	if len(valueValidations) == 0 {
		return node, nil
	}

	// callNodes are not automatically generated for primitive types. Generate one if the callNode does not exist
	if node == nil {
		node = &callNode{}
	}

	node.validationIsPrimitive = baseT.IsPrimitive()
	node.validationType = baseT
	node.validationTopLevelType = t
	node.elem = t.Kind == types.Pointer

	node.validations = valueValidations
	return node, nil
}

// build creates a tree of paths to fields (based on how they would be accessed in Go - pointer, elem,
// slice, or key) and the functions that should be invoked on each field. An in-order traversal of the resulting tree
// can be used to generate a Go function that invokes each nested function on the appropriate type. The return
// value may be nil if there are no functions to call on type or the type is a primitive (validation functions are only generated for
// structs today).
func (c *callTreeForType) build(t *types.Type, root bool) (*callNode, error) {
	parent := &callNode{}

	// TODO: Clarify or improve, this is what drops the list type generation right now
	if _, exists := c.validations[t]; !root && exists {
		return nil, nil
	}

	if root {
		// the root node is always a pointer
		parent.elem = true
	}

	// if the type already exists, don't build the tree for it and don't generate anything.
	// This is used to avoid recursion for nested recursive types.
	if c.currentlyBuildingTypes[t] {
		return nil, nil
	}
	// if type doesn't exist, mark it as existing
	c.currentlyBuildingTypes[t] = true

	defer func() {
		// The type will now acts as a parent, not a nested recursive type.
		// We can now build the tree for it safely.
		c.currentlyBuildingTypes[t] = false
	}()

	switch t.Kind {
	case types.Pointer:
		child, err := c.build(t.Elem, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			child.elem = true
			parent.children = append(parent.children, *child)
		}
	case types.Slice, types.Array:
		child, err := c.build(t.Elem, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			child.index = true
			if t.Elem.Kind == types.Pointer {
				child.elem = true
			}
			parent.children = append(parent.children, *child)
		}
	case types.Map:
		child, err := c.build(t.Elem, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			child.key = true
			parent.children = append(parent.children, *child)
		}

	case types.Struct:
		_, err := c.populateValidations(parent, t, t.CommentLines)
		if err != nil {
			return nil, err
		}
		for _, field := range t.Members {
			name := field.Name
			if len(name) == 0 {
				if field.Type.Kind == types.Pointer {
					name = field.Type.Elem.Name.Name
				} else {
					name = field.Type.Name.Name
				}
			}

			jsonName := "<unknown>"
			if tags, ok := lookupJSONTags(field); ok {
				jsonName = tags.name
			}

			child, err := c.build(field.Type, false)
			if err != nil {
				return nil, err
			}
			if child != nil {
				child.field = name
				child.jsonName = jsonName
				parent.children = append(parent.children, *child)
			} else {
				child, err := c.populateValidations(child, field.Type, field.CommentLines)
				if err != nil {
					return nil, err
				}
				if child != nil {
					child.field = name
					child.jsonName = jsonName
					parent.children = append(parent.children, *child)
				}
			}
		}
	case types.Alias:
		child, err := c.build(t.Underlying, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			parent.children = append(parent.children, *child)
		}
	}
	if len(parent.children) == 0 && len(parent.validations) == 0 {
		return nil, nil
	}

	if t.Kind == types.Struct && !parent.index && !parent.key {
		baseT, _ := resolveTypeAndDepth(t)
		parent.validationIsPrimitive = baseT.IsPrimitive()
		parent.validationType = t
		parent.validationTopLevelType = baseT
	}
	return parent, nil
}

// callNode represents an entry in a tree of Go type accessors - the path from the root to a leaf represents
// how in Go code an access would be performed. For example, if a validation function exists on a container
// lifecycle hook, to invoke that defaulter correctly would require this Go code:
//
//	for i := range pod.Spec.Containers {
//	  o := &pod.Spec.Containers[i]
//	  if o.LifecycleHook != nil {
//	    errs = append(errs, Validate_LifecycleHook(o.LifecycleHook, fieldPath)...)
//	  }
//	}
//
// That would be represented by a call tree like:
//
//	callNode
//	  field: "Spec"
//	  children:
//	  - field: "Containers"
//	    children:
//	    - index: true
//	      children:
//	      - field: "LifecycleHook"
//	        elem: true
//	        call:
//	        - Validate_LifecycleHook
//
// which we can traverse to build that Go struct (you must call the field Spec, then Containers, then range over
// that field, then check whether the LifecycleHook field is nil, before calling Validate_LifecycleHook on
// the pointer to that field).
type callNode struct {
	// field is the name of the Go member to access
	field string
	// jsonName is the json name of the member to access
	jsonName string
	// key is true if this is a map and we must range over the key and values
	key bool
	// index is true if this is a slice and we must range over the slice values
	index bool
	// elem is true if the previous elements refer to a pointer (typically just field)
	elem bool

	// children is the child call nodes that must also be traversed
	children []callNode

	// validations is the validations for the node
	validations validations

	// validationIsPrimitive tracks if the field is a primitive.
	validationIsPrimitive bool

	// validationType is the transitive underlying/element type of the node.
	// The provided default value literal or reference is expected to be
	// convertible to this type.
	//
	// e.g:
	//	node type = *string 			-> 	defaultType = string
	//	node type = StringPointerAlias 	-> 	defaultType = string
	// Only populated if validationIsPrimitive is true
	validationType *types.Type

	// validationTopLevelType is the final type the value should resolve to
	// This is in contrast to the default type, which resolves aliases and pointers.
	validationTopLevelType *types.Type
}

// CallNodeVisitorFunc is a function for visiting a call tree. ancestors is the list of all parents
// of this node to the root of the tree - will be empty at the root.
type CallNodeVisitorFunc func(ancestors []*callNode, node *callNode)

func (n *callNode) VisitInOrder(fn CallNodeVisitorFunc) {
	n.visitInOrder(nil, fn)
}

func (n *callNode) visitInOrder(ancestors []*callNode, fn CallNodeVisitorFunc) {
	fn(ancestors, n)
	ancestors = append(ancestors, n)
	for i := range n.children {
		n.children[i].visitInOrder(ancestors, fn)
	}
}

var (
	indexVariables = "ijklmnop"
	localVariables = "abcdefgh"
)

// varsForDepth creates temporary variables guaranteed to be unique within lexical Go scopes
// of this depth in a function. It uses canonical Go loop variables for the first 7 levels
// and then resorts to uglier prefixes.
func varsForDepth(depth int) (index, local string) {
	if depth > len(indexVariables) {
		index = fmt.Sprintf("i%d", depth)
	} else {
		index = indexVariables[depth : depth+1]
	}
	if depth > len(localVariables) {
		local = fmt.Sprintf("local%d", depth)
	} else {
		local = localVariables[depth : depth+1]
	}
	return
}

// WriteMethod performs an in-order traversal of the calltree, generating loops and if blocks as necessary
// to correctly turn the call tree into a method body that invokes all calls on all child nodes of the call tree.
// Depth is used to generate local variables at the proper depth.
func (n *callNode) WriteMethod(c *generator.Context, varName string, path pathPart, depth int, ancestors []*callNode, sw *generator.SnippetWriter) {
	isCallable := func(n callNode) bool {
		return n.validationType != nil && n.validationType.Kind == types.Struct && !n.index && !n.key
	}
	isPointer := n.elem && !n.index

	index, local := varsForDepth(depth)
	targs := generator.Args{
		"index": index,
		"local": local,
		"var":   varName,
	}

	if len(ancestors) > 0 {
		if isPointer {
			sw.Do("if $.var$ != nil {\n", targs)
			defer func() {
				sw.Do("}\n", nil)
			}()
		}
		if isCallable(*n) {
			n.writeCall(varName, path, isPointer, sw)
			return
		}
	}

	n.writeValidations(c, varName, path, index, isPointer, sw)

	switch {
	case n.index:
		sw.Do("for $.index$ := range $.var$ {\n", targs)
		if n.elem {
			sw.Do("$.local$ := $.var$[$.index$]\n", targs)
		} else {
			sw.Do("$.local$ := &$.var$[$.index$]\n", targs)
		}

		for _, child := range n.children { // TODO: only one child is expected
			childVarName := varName
			if len(child.field) > 0 {
				childVarName = local + "." + child.field
			}
			if n.validationType != nil && n.validationType.Kind == types.Struct {
				n.writeCall(local, pathPart{Index: index}, true, sw)
			} else {

				child.WriteMethod(c, childVarName, pathPart{Index: index}, depth+1, append(ancestors, n), sw)
			}
		}
		sw.Do("}\n", nil)
	case n.key:
		// Map keys are typed and cannot share the same index variable as arrays and other maps
		index = index + "_" + ancestors[len(ancestors)-1].field
		targs["index"] = index
		sw.Do("for $.index$_idx, $.index$ := range $.var$ {\n", targs)
		for _, child := range n.children {
			if n.validationType != nil && n.validationType.Kind == types.Struct {
				n.writeCall(index, pathPart{Key: index + "_idx"}, false, sw)
			} else {
				childVarName := index
				if len(child.field) > 0 {
					childVarName = index + "." + child.field
				}
				child.WriteMethod(c, childVarName, pathPart{Key: index + "_idx"}, depth+1, append(ancestors, n), sw)
			}
		}
		sw.Do("}\n", nil)
	default:
		for _, child := range n.children {
			childVarName := varName
			if len(child.field) > 0 {
				childVarName = varName + "." + child.field
			}
			child.WriteMethod(c, childVarName, pathPart{Name: child.jsonName}, depth+1, append(ancestors, n), sw)
		}
	}
}

// writeCall generates a list of function calls based on the calls field for the provided variable
// name and pointer.
func (n *callNode) writeCall(varName string, path pathPart, isVarPointer bool, sw *generator.SnippetWriter) {
	accessor := varName
	if !isVarPointer {
		accessor = "&" + accessor
	}

	targs := generator.Args{
		"fn":   n.validationType,
		"var":  accessor,
		"path": path,
	}

	sw.Do("errs = append(errs, $.fn|objectvalidationfn$($.var$, ", targs)

	if len(path.Key) > 0 {
		sw.Do("fldPath.Key($.path.Key$)", targs)
	} else if len(path.Name) > 0 {
		sw.Do("fldPath.Child(\"$.path.Name$\")", targs)
	} else {
		sw.Do("fldPath.Index($.path.Index$)", targs)
	}
	sw.Do(")...)\n", targs)
}

type pathPart struct {
	Index string
	Key   string
	Name  string
}

func (n *callNode) writeValidations(c *generator.Context, varName string, path pathPart, index string, isVarPointer bool, sw *generator.SnippetWriter) {
	accessor := varName
	if isVarPointer {
		accessor = "*" + accessor
	}

	if len(n.validations) == 0 {
		return
	}

	for _, v := range n.validations {
		fn, extraArgs := v.SignatureAndArgs()
		targs := generator.Args{
			"typeValidations": n.validations,
			"varName":         accessor,
			"path":            path,
			"index":           index,
			"varTopType":      n.validationTopLevelType,
			"invalid":         c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/util/validation/field", Name: "Invalid"}),
			"validationFn":    c.Universe.Type(fn),
		}

		// If default value is a literal then it can be assigned via var stmt
		sw.Do("errs = append(errs, $.validationFn|raw$(", targs)
		if len(path.Key) > 0 {
			sw.Do("fldPath.Key($.path.Key$)", targs)
		} else if len(path.Name) > 0 {
			sw.Do("fldPath.Child(\"$.path.Name$\")", targs)
		} else {
			sw.Do("fldPath.Index($.path.Index$)", targs)
		}
		sw.Do(", $.varName$", targs)
		for _, extraArg := range extraArgs {
			// TODO: Ideally we would not apply templating to values, but instead write them directly.
			sw.Do(", "+toGolangSourceDataLiteral(extraArg), nil)
		}
		sw.Do(")...)\n", targs)
	}
}

func toGolangSourceDataLiteral(value any) string {
	// For safety, be strict in what values we output to generated source, and ensure strings
	// are quoted.
	switch value.(type) {
	case uint, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, bool:
		return fmt.Sprintf("%v", value)
	case string:
		return fmt.Sprintf("%q", value)
	default:
		panic(fmt.Sprintf("Unsupported extraArg type: %T", value)) // TODO: handle error
	}
}
